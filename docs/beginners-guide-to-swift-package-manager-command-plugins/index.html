<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="https://theswiftdev.com/beginners-guide-to-swift-package-manager-command-plugins/">
    
    

    <title>Beginner&#39;s guide to Swift package manager command plugins - The.Swift.Dev.</title>
    <meta name="description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">

    <meta property="og:url" content="https://theswiftdev.com/beginners-guide-to-swift-package-manager-command-plugins/">
    <meta property="og:title" content="Beginner&#39;s guide to Swift package manager command plugins - The.Swift.Dev.">
    <meta property="og:description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">
    

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Beginner&#39;s guide to Swift package manager command plugins - The.Swift.Dev.">
    <meta name="twitter:description" content="Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.">
    

    <link rel="stylesheet" href="https://theswiftdev.com/css/modern-normalize.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/modern-base.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/variables.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/base.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/grid.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/navigation.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/footer.css">
    

    

    <link rel="shortcut icon" href="https://theswiftdev.com/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/icons/apple-touch-icon-180x180.png">

    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
        media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)">
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        media="(prefers-color-scheme: dark)"
    >
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>

<body>
    <div id="site-container">

    <header id="navigation">
        <a href="/">
            <picture>
                <img
                    src="https://theswiftdev.com/images/logos/logo.png"
                    alt="Logo of The.Swift.Dev."
                    title="The.Swift.Dev."
                >
            </picture>
        </a>
        <nav>
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/page/1/">Posts</a>
            <a href="/tags/">Tags</a>
            <a href="/authors/">Authors</a>
            <a href="/practical-server-side-swift/">My Book</a>
            </div>
        </nav>
    </header>

    <main id="page-container">
    
    <div class="article-with-toc">
        <div>
            <article class="post">
                <div class="meta">
                    <time datetime="2022/05/16">2022/05/16</time>
                     &middot; <span class="reading-time">9 min read</span>
                    
                </div>
                <h1>Beginner&#39;s guide to Swift package manager command plugins</h1>
                <hr>
                <p>Learn how to create command plugins for the Swift Package Manager to execute custom actions using SPM and other tools.</p>
                <section>
                
                <h2 id="introduction-to-swift-package-manager-plugins">Introduction to Swift Package Manager plugins</h2><p>First of all I’d like to talk a few words about the new SPM plugin infrastructure, that was introduced in the Swift 5.6 release. The very <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md" target="_blank">first proposal</a> describes the detailed design of the plugin API with some <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0303-swiftpm-extensible-build-tools.md#example-1-swiftgen" target="_blank">plugin examples</a>, which are quite handy. Honestly speaking I was a bit to lazy to carefully read through the entire documentation, it’s quite long, but long story short, you can create the following plugin types with the currently existing APIs:</p><ul><li>Build tools - can be invoked via the SPM targets<ul><li>pre-build - runs before the build starts</li><li>build - runs during the build</li></ul></li><li>Commands - can be invoked via the command line<ul><li>source code formatting - modifies the code inside package</li><li>documentation generation - generate docs for the package</li><li>custom - user defined intentions</li></ul></li></ul><p>For the sake of simplicity in this tutorial I’m only going to write a bit about the second category, aka. the command plugins. These plugins were a bit more interesting for me, because I wanted to integrate my deployment workflow into SPM, so I started to experiment with the plugin API to see how hard it is to build such a thing. Turns out it’s quite easy, but the developer experience it’s not that good. 😅</p><h2 id="building-a-source-code-formatting-plugin">Building a source code formatting plugin</h2><p>The very first thing I wanted to integrate with SPM was <a href="https://github.com/realm/SwiftLint" target="_blank">SwiftLint</a>, since I was not able to find a plugin implementation that I could use I started from scratch. As a starting point I was using the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md#example-2-formatting-source-code" target="_blank">example code</a> from the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md" target="_blank">Package Manager Command Plugins proposal</a>.</p><pre><code>mkdir Example
cd Example
swift package init --type=library
</code></pre><p>I started with a brand new package, using the swift package init command, then I modified the Package.swift file according to the documentation. I’ve also added <a href="https://github.com/realm/SwiftLint" target="_blank">SwiftLint</a> as a package dependency so SPM can download & build the and hopefully my custom plugin command can invoke the swiftlint executable when it is needed.</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/realm/SwiftLint", branch: "master"),
    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swiftlint", package: "SwiftLint"),
                ]),
    ]
)
</code></pre><p>I’ve created a <code>Plugins</code> directory with a <code>main.swift</code> file right next to the Sources folder, with the following contents.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let tool = try context.tool(named: "swiftlint")
        let toolUrl = URL(fileURLWithPath: tool.path.string)
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = toolUrl
            process.arguments = [
                "\(target.directory)",
                "--fix",
               // "--in-process-sourcekit" // this line will fix the issues...
            ]

            try process.run()
            process.waitUntilExit()
            
            if process.terminationReason == .exit && process.terminationStatus == 0 {
                print("Formatted the source code in \(target.directory).")
            }
            else {
                let problem = "\(process.terminationReason):\(process.terminationStatus)"
                Diagnostics.error("swift-format invocation failed: \(problem)")
            }
        }
    }
}
</code></pre><p>The snippet above should locate the swiftlint tool using the plugins context then it’ll iterate through the available package targets, filter out non source-module targets and format only those targets that contains actual Swift source files. The process object should simply invoke the underlying tool, we can wait until the child (swiftlint invocation) process exists and hopefully we’re good to go. 🤞</p><blockquote class="note"><p>NOTE: Update: <a href="https://x.com/k_alweheshy" target="_blank">kalKarmaDev</a> told me that it is possible to pass the <code>--in-process-sourcekit</code> argument to SwiftLint, this will fix the underlying issue and the source files are actually fixed.</p></blockquote><p>I wanted to list the available plugins & run my source code linter / formatter using the following shell commands, but unfortunately seems like the swiftlint invocation part failed for some strange reason.</p><pre><code class="language-sh">swift package plugin --list
swift package format-source-code #won't work, needs access to source files
swift package --allow-writing-to-package-directory format-source-code

# error: swift-format invocation failed: NSTaskTerminationReason(rawValue: 2):5
# what the hell happened? 🤔
</code></pre><p>Seems like there’s a problem with the exit code of the invoked swiftlint process, so I removed the success check from the plugin source to see if that’s causing the issue or not also tried to print out the executable command to debug the underlying problem.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let tool = try context.tool(named: "swiftlint")
        let toolUrl = URL(fileURLWithPath: tool.path.string)
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = toolUrl
            process.arguments = [
                "\(target.directory)",
                "--fix",
            ]

            print(toolUrl.path, process.arguments!.joined(separator: " "))

            try process.run()
            process.waitUntilExit()
        }
    }
}
</code></pre><p>Intentionally made a small “mistake” in the Example.swift source file, so I can see if the swiftlint –fix command will solve this issue or not. 🤔</p><pre><code class="language-swift">public struct Example {
    public private(set) var text = "Hello, World!"

    public init() {
        let xxx :Int = 123
    }
}
</code></pre><p>Turns out, when I run the plugin via the <a href="https://developer.apple.com/documentation/foundation/process" target="_blank">Process</a> invocation, nothing happens, but when I enter the following code manually into the shell, it just works.</p><pre><code class="language-sh">/Users/tib/Example/.build/arm64-apple-macosx/debug/swiftlint /Users/tib/Example/Tests/Example --fix
/Users/tib/Example/.build/arm64-apple-macosx/debug/swiftlint /Users/tib/Example/Tests/ExampleTests --fix
</code></pre><p>All right, so we definitely have a problem here… I tried to get the standard output message and error message from the running process, seems like swiftlint runs, but something in the SPM infrastructure blocks the code changes in the package. After several hours of debugging I decided to give a shot to <a href="https://github.com/apple/swift-format" target="_blank">swift-format</a>, because that’s what the official docs suggest. 🤷‍♂️</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
    ]
)
</code></pre><p>Changed both the <code>Package.swift</code> file and the plugin source code, to make it work with swift-format.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let swiftFormatTool = try context.tool(named: "swift-format")
        let swiftFormatExec = URL(fileURLWithPath: swiftFormatTool.path.string)
//        let configFile = context.package.directory.appending(".swift-format.json")
        
        for target in context.package.targets {
            guard let target = target as? SourceModuleTarget else { continue }

            let process = Process()
            process.executableURL = swiftFormatExec
            process.arguments = [
//                "--configuration", "\(configFile)",
                "--in-place",
                "--recursive",
                "\(target.directory)",
            ]
            try process.run()
            process.waitUntilExit()

            if process.terminationReason == .exit && process.terminationStatus == 0 {
                print("Formatted the source code in \(target.directory).")
            }
            else {
                let problem = "\(process.terminationReason):\(process.terminationStatus)"
                Diagnostics.error("swift-format invocation failed: \(problem)")
            }
        }
    }
}
</code></pre><p>I tried to run again the exact same package plugin command to format my source files, but this time swift-format was doing the code formatting instead of swiftlint.</p><pre><code class="language-sh">swift package --allow-writing-to-package-directory format-source-code
// ... loading dependencies
Build complete! (6.38s)
Formatted the source code in /Users/tib/Linter/Tests/ExampleTests.
Formatted the source code in /Users/tib/Linter/Sources/Example.
</code></pre><p>Worked like a charm, my Example.swift file was fixed and the : was on the left side… 🎊</p><pre><code class="language-swift">public struct Example {
    public private(set) var text = "Hello, World!"

    public init() {
        let xxx: Int = 123
    }
}
</code></pre><p>Yeah, I’ve made some progress, but it took me quite a lot of time to debug this issue and I don’t like the fact that I have to mess around with processes to invoke other tools… my gut tells me that SwiftLint is not following the standard shell exit status codes and that’s causing some issues, maybe it’s spawning child processes and that’s the problem, I really don’t know but I don’t wanted to waste more time on this issue, but I wanted to move forward with the other category. 😅</p><h2 id="integrating-the-docc-plugin-with-spm">Integrating the DocC plugin with SPM</h2><p>As a first step I added some dummy comments to my Example library to be able to see something in the generated documentation, nothing fancy just some one-liners. 📖</p><pre><code class="language-swift">/// This is just an example struct
public struct Example {

    /// this is the hello world text
    public private(set) var text = "Hello, World!"
    
    /// this is the init method
    public init() {
        let xxx: Int = 123
    }
}
</code></pre><p>I discovered that Apple has an <a href="https://github.com/apple/swift-docc-plugin" target="_blank">official DocC plugin</a>, so I added it as a dependency to my project.</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
        .package(url: "https://github.com/apple/swift-docc-plugin", from: "1.0.0"),

    ],
    targets: [
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
    ]
)
</code></pre><p>Two new plugin commands were available after I executed the plugin list command.</p><pre><code class="language-sh">swift package plugin --list

# ‘format-source-code’ (plugin ‘MyCommandPlugin’ in package ‘Example’)
# ‘generate-documentation’ (plugin ‘Swift-DocC’ in package ‘SwiftDocCPlugin’)
# ‘preview-documentation’ (plugin ‘Swift-DocC Preview’ in package ‘SwiftDocCPlugin’)
</code></pre><p>Tried to run the first one, and fortunately the doccarchive file was generated. 😊</p><pre><code class="language-sh">swift package generate-documentation
# Generating documentation for 'Example'...
# Build complete! (0.16s)
# Converting documentation...
# Conversion complete! (0.33s)
# Generated DocC archive at '/Users/tib/Linter/.build/plugins/Swift-DocC/outputs/Example.doccarchive'
</code></pre><p>Also tried to preview the documentation, there was a note about the –disable-sandbox flag in the output, so I simply added it to my original command and…</p><pre><code class="language-sh">swift package preview-documentation 
# Note: The Swift-DocC Preview plugin requires passing the '--disable-sandbox' flag
swift package --disable-sandbox preview-documentation
</code></pre><p>Magic. It worked and my documentation was available. Now this is how plugins should work, I loved this experience and I really hope that more and more official plugins are coming soon. 😍</p><h2 id="building-a-custom-intent-command-plugin">Building a custom intent command plugin</h2><p>I wanted to build a small executable target with some bundled resources and see if a plugin can deploy the executable binary with the resources. This could be very useful when I deploy feather apps, I have multiple module bundles there and now I have to manually copy everything… 🙈</p><pre><code class="language-swift">// swift-tools-version: 5.6
import PackageDescription

let package = Package(
    name: "Example",
    platforms: [
        .macOS(.v10_15),
    ],
    products: [
        .library(name: "Example", targets: ["Example"]),
        .executable(name: "MyExample", targets: ["MyExample"]),
        .plugin(name: "MyCommandPlugin", targets: ["MyCommandPlugin"]),
        .plugin(name: "MyDistCommandPlugin", targets: ["MyDistCommandPlugin"]),
    ],
    dependencies: [
        .package(url: "https://github.com/apple/swift-format", exact: "0.50600.1"),
        .package(url: "https://github.com/apple/swift-docc-plugin", from: "1.0.0"),

    ],
    targets: [
        .executableTarget(name: "MyExample",
                          resources: [
                            .copy("Resources"),
                          ], plugins: [
                            
                          ]),
        .target(name: "Example", dependencies: []),
        .testTarget(name: "ExampleTests", dependencies: ["Example"]),
       
        .plugin(name: "MyCommandPlugin",
                capability: .command(
                    intent: .sourceCodeFormatting(),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command reformats source files")
                    ]
                ),
                dependencies: [
                    .product(name: "swift-format", package: "swift-format"),
                ]),
        
        .plugin(name: "MyDistCommandPlugin",
                capability: .command(
                    intent: .custom(verb: "dist", description: "Create dist archive"),
                    permissions: [
                        .writeToPackageDirectory(reason: "This command deploys the executable")
                    ]
                ),
                dependencies: [
                ]),
    ]
)
</code></pre><p>As a first step I created a new executable target called MyExample and a new MyDistCommandPlugin with a custom verb. Inside the Sources/MyExample/Resources folder I’ve placed a simple test.json file with the following contents.</p><pre><code class="language-json">{
    "success": true
}
</code></pre><p>The main.swift file of the MyExample target looks like this. It just validates that the resource file is available and it simply decodes the contents of it and prints everything to the standard output. 👍</p><pre><code class="language-swift">import Foundation

guard let jsonFile = Bundle.module.url(forResource: "Resources/test", withExtension: "json") else {
    fatalError("Bundle file not found")
}
let jsonData = try Data(contentsOf: jsonFile)

struct Json: Codable {
    let success: Bool
}

let json = try JSONDecoder().decode(Json.self, from: jsonData)

print("Is success?", json.success)
</code></pre><p>Inside the Plugins folder I’ve created a main.swift file under the MyDistCommandPlugin folder.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyDistCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        
        // ...
    }
}
</code></pre><p>Now I was able to re-run the swift package plugin –list command and the dist verb appeared in the list of available commands. Now the only question is: how do we get the artifacts out of the build directory? Fortunately the <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0332-swiftpm-command-plugins.md#example-3-building-deployment-artifacts" target="_blank">3rd example</a> of the commands proposal is quite similar.</p><pre><code class="language-swift">import PackagePlugin
import Foundation

@main
struct MyDistCommandPlugin: CommandPlugin {
    
    func performCommand(context: PluginContext, arguments: [String]) throws {
        let cpTool = try context.tool(named: "cp")
        let cpToolURL = URL(fileURLWithPath: cpTool.path.string)

        let result = try packageManager.build(.product("MyExample"), parameters: .init(configuration: .release, logging: .concise))
        guard result.succeeded else {
            fatalError("couldn't build product")
        }
        guard let executable = result.builtArtifacts.first(where : { $0.kind == .executable }) else {
            fatalError("couldn't find executable")
        }
        
        let process = try Process.run(cpToolURL, arguments: [
            executable.path.string,
            context.package.directory.string,
        ])
        process.waitUntilExit()

        let exeUrl = URL(fileURLWithPath: executable.path.string).deletingLastPathComponent()
        let bundles = try FileManager.default.contentsOfDirectory(atPath: exeUrl.path).filter { $0.hasSuffix(".bundle") }

        for bundle in bundles {
            let process = try Process.run(cpToolURL, arguments: ["-R",
                                                                    exeUrl.appendingPathComponent(bundle).path,
                                                                    context.package.directory.string,
                                                                ])
            process.waitUntilExit()
        }
    }
}
</code></pre><p>So the only problem was that I was not able to get back the bundled resources, so I had to use the URL of the executable file, drop the last path component and read the contents of that directory using the FileManager to get back the .bundle packages inside of that folder.</p><p>Unfortunately the builtArtifacts property only returns the executables and libraries. I really hope that we’re going to get support for bundles as well in the future so this hacky solution can be avoided for good. Anyway it works just fine, but still it’s a hack, so use it carefully. ⚠️</p><pre><code class="language-sh">swift package --allow-writing-to-package-directory dist
./MyExample 
#Is success? true
</code></pre><p>I was able to run my custom dist command without further issues, of course you can use additional arguments to customize your plugin or add more flexibility, the examples in the proposal are pretty much okay, but it’s quite unfortunate that there is no official documentation for Swift package manager plugins just yet. 😕</p><h2 id="conclusion">Conclusion</h2><p>Learning about command plugins was fun, but in the beginning it was annoying because I expected a bit better developer experience regarding the tool invocation APIs. In summary I can say that this is just the beginning. It’s just like the async / await and actors addition to the Swift language. The feature itself is there, it’s mostly ready to go, but not many developers are using it on a daily basis. These things will require time and hopefully we’re going to see a lot more plugins later on… 💪</p>
                    
                </section>
    
                <footer>
                    <br>
                    <time datetime=""></time>
    
                    
                    <div class="author-list">
                        <a href="https://theswiftdev.com/authors/tibor-bodecs/">
                        <img class="small rounded" src="/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                        </a>
                    </div>
                    <div class="tag-list">
                        <a href="https://theswiftdev.com/tags/swift-package-manager/"><small>Swift Package Manager</small></a>
                    </div>
                    
                    <p>
                        <a href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/beginners-guide-to-swift-package-manager-command-plugins/" target="_blank">
                            <strong>Share this article</strong>
                        </a>
                        <br>Thank you. 🙏
                    </p>
                </footer>
                            
                <section class="group">
                    <h4>Related posts</h4>                
                    <div class="grid grid-221">
                        <div class="card">
                            
                            
                            <div class="author-list">
                                <a href="https://theswiftdev.com/authors/tibor-bodecs/">
                                <img class="small rounded" src="/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                                </a>
                            </div>
                            <div class="meta">
                                <time datetime="2022/01/20">2022/01/20</time>
                                 &middot; <span class="reading-time">4 min read</span>
                            </div>
                            
                            <h2 class="title"><a href="https://theswiftdev.com/how-to-create-a-swift-package-collection/" target="">How to create a Swift package collection?</a></h2>
                            <hr>
                            <p>In this tutorial I&#39;m going to show you how to create your own package collection from your favorite Swift libraries.</p>
                        
                            <div class="tag-list">
                                <a href="https://theswiftdev.com/tags/swift-package-manager/"><small>Swift Package Manager</small></a>
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                                <a href="https://theswiftdev.com/authors/tibor-bodecs/">
                                <img class="small rounded" src="/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                                </a>
                            </div>
                            <div class="meta">
                                <time datetime="2022/05/24">2022/05/24</time>
                                 &middot; <span class="reading-time">4 min read</span>
                            </div>
                            
                            <h2 class="title"><a href="https://theswiftdev.com/introduction-to-spm-artifact-bundles/" target="">Introduction to SPM artifact bundles</a></h2>
                            <hr>
                            <p>In this tutorial I&#39;m going to show you how to use the new binary target related artifact bundle using the Swift package manager.</p>
                        
                            <div class="tag-list">
                                <a href="https://theswiftdev.com/tags/swift-package-manager/"><small>Swift Package Manager</small></a>
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                                <a href="https://theswiftdev.com/authors/tibor-bodecs/">
                                <img class="small rounded" src="/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                                </a>
                            </div>
                            <div class="meta">
                                <time datetime="2017/11/19">2017/11/19</time>
                                 &middot; <span class="reading-time">5 min read</span>
                            </div>
                            
                            <h2 class="title"><a href="https://theswiftdev.com/swift-package-manager-tutorial/" target="">Swift Package Manager tutorial</a></h2>
                            <hr>
                            <p>Learn how to use the Swift Package Manager to handle external dependencies, create your library or app on macOS and Linux.</p>
                        
                            <div class="tag-list">
                                <a href="https://theswiftdev.com/tags/swift-package-manager/"><small>Swift Package Manager</small></a>
                            </div>
                        </div>
                    </div>
                </section>
    
            </article>
        </div>
        
        <div>
            <div class="book">
                <a href="https://theswiftdev.gumroad.com/l/practical-server-side-swift" target="_blank">
                    <img src="https://theswiftdev.com/book/practical-server-side-swift-cover.png" alt="Practical Server Side Swift cover image">
                </a>
                <h3>
                    <a href="https://theswiftdev.gumroad.com/l/practical-server-side-swift" target="_blank">Get the Practical Server Side Swift book</a>
                </h3>
                <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
                <a class="cta" href="https://theswiftdev.gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
            </div>
            
            
            <aside id="toc">
                <h4>On this page</h4>
                <ul>
                    <li class="first-level">
                        <a href="#introduction-to-swift-package-manager-plugins">Introduction to Swift Package Manager plugins</a>
                        <ul>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#building-a-source-code-formatting-plugin">Building a source code formatting plugin</a>
                        <ul>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#integrating-the-docc-plugin-with-spm">Integrating the DocC plugin with SPM</a>
                        <ul>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#building-a-custom-intent-command-plugin">Building a custom intent command plugin</a>
                        <ul>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#conclusion">Conclusion</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </aside>
            
    
        </div>
    </div>
    
    </main>

    <footer id="site-footer">
        <div class="grid grid-421">
    
            <picture>
                <img
                    id="logo-image"
                    src="https://theswiftdev.com/images/logos/logo-large.png"
                    alt="Logo of The.Swift.Dev."
                    title="The.Swift.Dev."
                >
            </picture>
            
            <div>
                <span style="display: block; height: 32px;">&nbsp;</span>
                <h4>The.Swift.Dev</h4>
                <p><small><a href="https://theswiftdev.com/" target="_blank">theswiftdev.com</a></small></p>
                <ul>
                    <li><a href="https://github.com/theswiftdev/" target="_blank">GitHub</a></li>
                    <li><a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a></li>
                    <li><a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a></li>
                </ul>
            </div>
            
            <div>
                
            </div>
            
            <div>
                <a href="https://theswiftdev.com/authors/tibor-bodecs/">
                <img class="small rounded" src="https://theswiftdev.com/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                </a>
                <h4><a href="https://theswiftdev.com/authors/tibor-bodecs/">Tibor Bödecs</a></h4>
                <p><small><a href="https://binarybirds.com/" target="_blank">Binary Birds Kft.</a></small></p>
                <ul>
                    <li><a href="mailto:mail.tib@gmail.com" target="_blank">Email</a></li>
                    <li><a href="https://github.com/tib/" target="_blank">GitHub</a></li>
                    <li><a href="https://x.com/tiborbodecs" target="_blank">X (Twitter)</a></li>
                    <li><a href="https://mastodon.social/@tiborbodecs" target="_blank">Mastodon</a></li>
                </ul>
            </div>
            
        </div>
        
        <section class="grid grid-221">
            <small>Tibor Bödecs &copy; 2015 - 2024</small>
            <small>This site was generated using <a href="https://swift.org/" target="_blank">Swift</a> & <a href="https://github.com/binarybirds/toucan" target="_blank">Toucan</a>.</small>
        </section>
    </footer>

    </div>

    
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>How to write services for VIPER? - The.Swift.Dev.</title>
    
    <meta name="description" content="Not everything is a VIPER module. In this article I'll show you how do I separate the service layer from the modules, using Swift.">
    
    <meta property="og:title" content="How to write services for VIPER? - The.Swift.Dev.">
    <meta property="og:description" content="Not everything is a VIPER module. In this article I'll show you how do I separate the service layer from the modules, using Swift.">
    <meta property="og:url" content="https://theswiftdev.com/how-to-write-services-for-viper/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/how-to-write-services-for-viper/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="How to write services for VIPER? - The.Swift.Dev.">
    <meta name="twitter:description" content="Not everything is a VIPER module. In this article I'll show you how do I separate the service layer from the modules, using Swift.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/how-to-write-services-for-viper/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2019/09/25">2019/09/25</time>
            <h1 class="title">How to write services for VIPER?</h1>
            <p class="excerpt">Not everything is a VIPER module. In this article I'll show you how do I separate the service layer from the modules, using Swift.</p>
            <div class="meta">
                <span class="tag">VIPER</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/how-to-write-services-for-viper/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <p>I can imagine that you just started to write your <a href="https://theswiftdev.com/2018/03/12/the-ultimate-viper-architecture-tutorial/">first VIPER module</a> and you might wonder: where should I put all my network communication, CoreLocation, CoreData or "whatever service" code, that's not related to the <a href="https://theswiftdev.com/2019/03/11/viper-best-practices-for-ios-developers/">user interface</a> at all?</p><blockquote><p>To the service layer!</p></blockquote><p>I usually call these the API, location, storage as a service, because they serve your modules with some kind of information. Plus they can encapsulate the underlying layer, providing a well-defined API interface for your VIPER modules. </p><p>Ok, but what about interactors? Shouldn't I implement this kind of stuff there?</p><p>Well, my answer is no, because there is a major difference between services and interactors. While a service is just a "dummy" wrapper around e.g. a RESTful API, another one around the CoreData storage, an interactor however could use both of them to request some kind of data though the API, and save it locally using the storage service. Interactors can also do sorting, filtering, transformation between Data Transfer Objects (DTOs) and entities, more about them later.</p><p>Enough theory for now, let's create a new service.</p><h2>Service interfaces</h2><p>This time as the Protocol Objective Programming paradigm says:</p><blockquote><p>We start designing our system by defining protocols.</p></blockquote><p>Our first one is going to be a really simple one for all the services:</p><pre><code class="language-swift"><span class="keyword">protocol</span> ServiceInterface: <span class="keyword">class</span> {
    <span class="keyword">func</span> setup()
}

<span class="keyword">extension</span> <span class="type">ServiceInterface</span> {

    <span class="keyword">func</span> setup() {
        <span class="comment">// do nothing...</span>
    }
}</code></pre><p>The setup will be called for each service during the service initialization process. We can extend the base service so we don't have to implement this method, but only if we really have to do something, like setting up our CoreData stack.</p><p>Next we can come up with our API service, in this case I'm going to implement a dummy endpoint that loads some data using <a href="https://theswiftdev.com/2019/08/15/urlsession-and-the-combine-framework/">the new Combine framework with URLSession</a>, but of course you can go with completion blocks or <a href="https://theswiftdev.com/2019/05/28/promises-in-swift-for-beginners/">Promises</a> as well.</p><pre><code class="language-swift"><span class="keyword">protocol</span> ApiServiceInterface: <span class="type">ServiceInterface</span> {

    <span class="keyword">func</span> todos() -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt;
}</code></pre><p>Nowadays I'm using a HTTP namespace for all my network related stuff, like request methods, responses, errors, etc. Feel free to extend it based on your needs.</p><pre><code class="language-swift"><span class="keyword">enum</span> HTTP {

    <span class="keyword">enum</span> Method: <span class="type">String</span> {
        <span class="keyword">case get</span>
        <span class="comment">//...</span>
    }
    <span class="keyword">enum</span> Error: <span class="type">LocalizedError</span> {
        <span class="keyword">case</span> invalidResponse
        <span class="keyword">case</span> statusCode(<span class="type">Int</span>)
        <span class="keyword">case</span> unknown(<span class="type">Swift</span>.<span class="type">Error</span>)
    }
}</code></pre><p>As you can see it's quite lightweight, but it's extremely handy. We haven't talked about the TodoObject yet. That's going to be our very first DTO. </p><h2>Data Transfer Objects</h2><blockquote><p>A data transfer object (DTO) is an object that carries data between processes. - <a href="https://en.wikipedia.org/wiki/Data_transfer_object" target="_blank">Wikipedia</a></p></blockquote><p>In this case we're not talking about processes, but services &amp; VIPER modules. They exists so we can decouple our service layer from our modules. The interactor can transform the DTO into a module entity, so all other parts of the VIPER module will be completely independent from the service. Worth to mention that a DTO is usually really simple, in a RESTful API service, a DTO can implement the <code>Codable</code> interface and nothing more or for <code>CoreData</code> it can be just a <code>NSManagedObject</code> subclass.</p><pre><code class="language-swift"><span class="keyword">struct</span> TodoObject: <span class="type">Codable</span> {
    <span class="keyword">let</span> id: <span class="type">Int</span>
    <span class="keyword">let</span> title: <span class="type">String</span>
    <span class="keyword">let</span> completed: <span class="type">Bool</span>
}</code></pre><p>You can also use a simple DTO to wrap your request parameters. For example you can use a TodoRequestObject which can contain some filter or sorting parameters. You might noticed that I always use the Object suffix for my DTO's, that's a personal preference, but it helps me differentiate them from entities.</p><p>Going a little bit further this way: you can publish your entire service layer as an encapsulated Swift package using <a href="https://theswiftdev.com/2019/01/14/all-about-the-swift-package-manager-and-the-swift-toolchain/">SPM</a>, from Xcode 11 these packages are natively supported so if you're still using CocoaPods, you should consider <a href="https://theswiftdev.com/2019/09/02/migrating-from-cocoapods-to-swift-package-manager/">migrating to the Swift Package Manager</a> as soon as possible.</p><h2>Service implementations</h2><p>Before we start building our real service implementation, it's good to have a fake one for demos or testing purposes. I call this fake, because we're going to return a fixed amount of fake data, but it's close to our real-world implementation. If our request would include filtering or sorting, then this fake implementation service should filter or sort our response like the final one would do it.</p><pre><code class="language-swift"><span class="keyword">final class</span> FakeApiService: <span class="type">ApiServiceInterface</span> {

    <span class="keyword">var</span> delay: <span class="type">TimeInterval</span>

    <span class="keyword">init</span>(delay: <span class="type">TimeInterval</span> = <span class="number">1</span>) {
        <span class="keyword">self</span>.<span class="property">delay</span> = delay
    }

    <span class="keyword">private func</span> fakeRequest&lt;T&gt;(response: <span class="type">T</span>) -&gt; <span class="type">AnyPublisher</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; {
        <span class="keyword">return</span> <span class="type">Future</span>&lt;<span class="type">T</span>, <span class="type">HTTP</span>.<span class="type">Error</span>&gt; { promise <span class="keyword">in</span>
            <span class="call">promise</span>(.<span class="call">success</span>(response))
        }
        .<span class="call">delay</span>(for: .<span class="keyword">init</span>(<span class="keyword">self</span>.<span class="property">delay</span>), scheduler: <span class="type">RunLoop</span>.<span class="property">main</span>)
        .<span class="call">eraseToAnyPublisher</span>()
    }

    <span class="keyword">func</span> todos() -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; {
        <span class="keyword">let</span> todos = [
            <span class="type">TodoObject</span>(id: <span class="number">1</span>, title: <span class="string">"first"</span>, completed: <span class="keyword">false</span>),
            <span class="type">TodoObject</span>(id: <span class="number">2</span>, title: <span class="string">"second"</span>, completed: <span class="keyword">false</span>),
            <span class="type">TodoObject</span>(id: <span class="number">3</span>, title: <span class="string">"third"</span>, completed: <span class="keyword">false</span>),
        ]
        <span class="keyword">return self</span>.<span class="call">fakeRequest</span>(response: todos)
    }
}</code></pre><p>I like to add some delay to my fake objects, because it helps me testing the UI stack. I'm a big fan of Scott's <a href="https://www.scotthurff.com/posts/why-your-user-interface-is-awkward-youre-ignoring-the-ui-stack/" target="_blank">how to fix a bad user interface</a> article. You should definitely read it, because it's amazing and it will help you to design better products. </p><p>Moving forward, here is the actual "real-world" implementation of the service:</p><pre><code class="language-swift"><span class="keyword">final class</span> MyApiService: <span class="type">ApiServiceInterface</span> {

    <span class="keyword">let</span> baseUrl: <span class="type">String</span>

    <span class="keyword">init</span>(baseUrl: <span class="type">String</span>) {
        <span class="keyword">self</span>.<span class="property">baseUrl</span> = baseUrl
    }

    <span class="keyword">func</span> todos() -&gt; <span class="type">AnyPublisher</span>&lt;[<span class="type">TodoObject</span>], <span class="type">HTTP</span>.<span class="type">Error</span>&gt; {
        <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="keyword">self</span>.<span class="property">baseUrl</span> + <span class="string">"todos"</span>)!
        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: url)
        request.<span class="property">httpMethod</span> = <span class="type">HTTP</span>.<span class="type">Method</span>.<span class="property">get</span>.<span class="property">rawValue</span>.<span class="call">uppercased</span>()

        <span class="keyword">return</span> <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTaskPublisher</span>(for: request)
        .<span class="call">tryMap</span> { data, response <span class="keyword">in
            guard let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span> <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.<span class="property">invalidResponse</span>
            }
            <span class="keyword">guard</span> httpResponse.<span class="property">statusCode</span> == <span class="number">200</span> <span class="keyword">else</span> {
                <span class="keyword">throw</span> <span class="type">HTTP</span>.<span class="type">Error</span>.<span class="call">statusCode</span>(httpResponse.<span class="property">statusCode</span>)
            }
            <span class="keyword">return</span> data
        }
        .<span class="call">decode</span>(type: [<span class="type">TodoObject</span>].<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())
        .<span class="call">mapError</span> { error -&gt; <span class="type">HTTP</span>.<span class="type">Error</span> <span class="keyword">in
            if let</span> httpError = error <span class="keyword">as</span>? <span class="type">HTTP</span>.<span class="type">Error</span> {
                <span class="keyword">return</span> httpError
            }
            <span class="keyword">return</span> <span class="type">HTTP</span>.<span class="type">Error</span>.<span class="call">unknown</span>(error)
        }
        .<span class="call">eraseToAnyPublisher</span>()
    }
}</code></pre><p>The thing is that we could make this even better, but for the sake of simplicity I'm going to "hack-together" the implementation. I don't like the implicitly unwrapped url, and many more little details, but for learning purposes it's totally fine. </p><p>So the big question is now, how to put things togehter? I mean we have a working service implementation, a fake service implementation, but how the hell should we put everything into a real Xcode project, without shipping fake code into production?</p><h2>Target environments</h2><p>Usually you will have a live production environment, a development environment, maybe a staging environment and some more for QA, UAT, or demo purposes. Things can vary for these environments such as the final API url or the app icon, etc.</p><p>This time I'm going to set up a project with 3 separate environments:</p><ul><li>Production</li><li>Development</li><li>Fake</li></ul><p>If you start with a new project you'll have one primary (non-test) target by default. You can duplicate a target by right-clicking on it. Let's do this two times.</p><p>I usually go with a suffix for the target and scheme names, except for the production environment, where I use the "base name" without the -Production postfix.</p><p>As you can see on the screenshot I have a basic folder structure for the environments. There has to be a separate <code>Info.plist</code> file for every target, so I put them into the proper Assets folder. The FakeApiService.swift is only part of the fake target, and every other file is shared. Wait, what the heck is a ServiceBuilder?</p><h2>Dependency injection</h2><p>Multiple environment means that we have to use the right service (or configuration) for every build target. I'm using <a href="https://theswiftdev.com/2018/07/17/swift-dependency-injection-design-pattern/">the dependency injection design pattern</a> for this purpose. A service builder is just a protocol that helps to achieve this goal. It defines how to setup services based on the environment. Let me show you how it works.</p><pre><code class="language-swift"><span class="keyword">protocol</span> ServiceBuilderInterface {

    <span class="keyword">var</span> api: <span class="type">ApiServiceInterface</span> { <span class="keyword">get</span> }

    <span class="keyword">func</span> setup()
}

<span class="keyword">extension</span> <span class="type">ServiceBuilderInterface</span> {

    <span class="keyword">func</span> setup() {
        <span class="keyword">self</span>.<span class="property">api</span>.<span class="call">setup</span>()
    }
}</code></pre><p>Now for each target (environment) I implement the ServiceBuilderInterface in an actual ServiceBuilder.swift file, so I can setup my services just as I need them.</p><pre><code class="language-swift"><span class="keyword">final class</span> ServiceBuilder: <span class="type">ServiceBuilderInterface</span> {

    <span class="keyword">lazy var</span> api: <span class="type">ApiServiceInterface</span> = {
        <span class="comment">// this can be the url of the development server</span>
        <span class="type">MyApiService</span>(baseUrl: <span class="string">"https://jsonplaceholder.typicode.com"</span>)
    }()
}</code></pre><p>I usually have a base service-interactor class that will receive all the services during the initialization process. So I can swap out anything without a hassle.</p><pre><code class="language-swift"><span class="keyword">class</span> ServiceInteractor {

    <span class="keyword">let</span> services: <span class="type">ServiceBuilderInterface</span>

    <span class="keyword">init</span>(services: <span class="type">ServiceBuilderInterface</span> = <span class="type">App</span>.<span class="property">shared</span>.<span class="property">services</span>) {
        <span class="keyword">self</span>.<span class="property">services</span> = services
    }
}</code></pre><p>DI is great, but I don't like to repeat myself too much, that's why I'm providing a default value for this property, which is located in my only <a href="https://theswiftdev.com/2018/05/22/swift-singleton-design-pattern/">singleton class</a> called App. I know, singletons are evil, but I already have an anti-pattern here so it really doesn't matter if I introduce one more, right? #bastard #singleton </p><pre><code class="language-swift"><span class="keyword">final class</span> App {

    <span class="keyword">let</span> services = <span class="type">ServiceBuilder</span>()

    <span class="comment">// MARK: - singleton</span>

    <span class="keyword">static let</span> shared = <span class="type">App</span>()

    <span class="keyword">private init</span>() {
        <span class="comment">// do nothing...</span>
    }

    <span class="comment">// MARK: - api</span>

    <span class="keyword">func</span> setup() {
        <span class="keyword">self</span>.<span class="property">services</span>.<span class="call">setup</span>()
    }
}</code></pre><p>This setup is extremely useful if it comes to testing. You can simply mock out all the services if you want to test an interactor. It's also nice and clean, because you can reach your methods in the interactors like this: <code>self.services.api.todos()</code></p><blockquote><p>You can apply the same pattern for your modules, I mean you can have for example a ModuleBuilder that implements a ModuleBuilderInterface and all the routers can have them through DI, so you don't have to initialize everything from scratch all the tim using the build function of the module. </p></blockquote><p>Still I want to clarify one more thing...</p><h2>Object, model, entity, what the...?</h2><p>A little bit about naming conventions (I also use these as suffixes all the time):</p><ul><li>Object</li><li>Entity</li><li>Model</li></ul><p>In my dictionary an Object is always a DTO, it only lives in the service layer. It's a freakin dumb one, without any more purpose than providing a nice Swiftish API. This means you don't have to deal with JSON objects or anything crazy like that, but you can work directly with these objects, which is usually a nice to have feature.</p><p>An Entity is related to a VIPER module. Its purpose is to act as a communication object that can be passed around between the view, interactor, presenter, router or as a parameter to another module. It can encapsulate the local stuff that's required for the module. This means if something changes in the service layer (a DTO maybe) your module will be able to work, you only have to align your interactor. </p><blockquote><p>Still, sometimes I'm completely skipping entities, but I know I shouldn't. :(</p></blockquote><p>A Model refers to a view-model, which is part of my <a href="https://theswiftdev.com/2019/05/23/building-input-forms-for-ios-apps/">component based UI building approach</a> on top of the <a href="https://theswiftdev.com/2018/04/17/ultimate-uicollectionview-guide-with-ios-examples-written-in-swift/">UICollectionView</a> class. You should check out the links if you want to learn more about it, the syntax is very similar to <a href="https://theswiftdev.com/2019/09/18/how-to-build-swiftui-apps-using-viper/">SwiftUI</a>, but it's obviously not as high-level. In summary a model always has the data that's required to render a view, nothing more and nothing less.</p><p>I hope this little article will help you to structure your apps better. VIPER can be quite problematic sometimes, because of the way you have to architect the apps. Using these kind of services is a nice approach to separate all the different API connections, sensors, and many more, and finally please remember:</p><blockquote><p>Not everything is a VIPER module.</p></blockquote><p>You can download the source files for this article using The.Swift.Dev tutorials repository on <a href="https://github.com/theswiftdev/tutorials" target="_blank">GitHub</a>. Thanks for reading, if you haven't done it yet please subscribe to my newsletter below, or send me ideas, feedbacks through Twitter. </p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/how-to-write-services-for-viper/"
        target="_blank"
    >
        Share this article
    </a>
    <br> Thank you. </p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B枚decs" 
        title="Tibor B枚decs"
    >
    <h3>Tibor B枚decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> 路 
        <a href="https://x.com/tiborbodecs" target="_blank">X</a> 路 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> 路
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> 路
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B枚decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>

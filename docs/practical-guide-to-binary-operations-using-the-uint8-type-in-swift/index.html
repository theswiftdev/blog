<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Practical guide to binary operations using the UInt8 type in Swift - The.Swift.Dev.</title>
    
    <meta name="description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">
    
    <meta property="og:title" content="Practical guide to binary operations using the UInt8 type in Swift - The.Swift.Dev.">
    <meta property="og:description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">
    <meta property="og:url" content="https://theswiftdev.com/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/">
    <meta property="og:image" content="https://theswiftdev.com/images/assets/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/cover.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@tiborbodecs">
    <meta name="twitter:creator" content="@tiborbodecs">
    <meta name="twitter:title" content="Practical guide to binary operations using the UInt8 type in Swift - The.Swift.Dev.">
    <meta name="twitter:description" content="Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.">
    <meta name="twitter:image" content="https://theswiftdev.com/images/assets/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/cover.jpg">
    
    <link rel="stylesheet" href="https://theswiftdev.com/css/style.css">
    <link rel="stylesheet" href="https://theswiftdev.com/css/syntax.css">
    
    <link rel="mask-icon" sizes="any" href="https://theswiftdev.com/images/icons/icon.svg">

    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://theswiftdev.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://theswiftdev.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://theswiftdev.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://theswiftdev.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://theswiftdev.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://theswiftdev.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://theswiftdev.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://theswiftdev.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://theswiftdev.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://theswiftdev.com/images/icons/apple-touch-icon-180x180.png">
    
</head>

<body>
    <a href="https://theswiftdev.gumroad.com" class="ribbon">
        üìñ
    </a>
    <header id="page-header">
        <a href="https://theswiftdev.com/">
            <img 
                id="logo-image"
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >
        </a>
    </header>
    
    <main>

        <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2021/09/16">2021/09/16</time>
            <h1 class="title">Practical guide to binary operations using the UInt8 type in Swift</h1>
            <p class="excerpt">Introduction to the basics of signed number representation and some practical binary operation examples in Swift using UInt8.</p>
            <div class="meta">
                <span class="tag">Swift</span>
<span class="tag">UInt8</span>
            </div>
        </section>
        <section class="wrapper">
            <img id="post-image" src="https://theswiftdev.com/images/assets/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/cover.jpg">
        </section>
    </header>

    <div id="contents">
        <section class="content-wrapper">
            <h2>Integer types in Swift</h2><p>The Swift programming language has a bunch of different integer types. The Swift integer APIs were cleaned up by an old proposal named <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0104-improved-integers.md" target="_blank">Protocol-oriented Integers</a>, which resulted in a more generic way of expressing these kind of data types.</p><p><a href="https://andybargh.com/swift-numeric-data-types/" target="_blank">Numeric data types</a> in Swift are type safe by default, this makes a bit harder to perform operation using different integer (or floating point) types. Integers are divided into two main groups: signed and unsigned integers. In addition each members of these groups can be categorized by bit sizes. There are 8, 16, 32 &amp; 64 bit long signed &amp; unsigned integers plus generic integers. ü§î</p><p>Generic integers:</p><ul><li><a href="https://developer.apple.com/documentation/swift/int" target="_blank">Int</a> (32 or 64 bit)</li><li><a href="https://developer.apple.com/documentation/swift/uint" target="_blank">UInt</a> (32 or 64 bit)</li></ul><p>Signed integers:</p><ul><li><a href="https://developer.apple.com/documentation/swift/int8" target="_blank">Int8</a></li><li><a href="https://developer.apple.com/documentation/swift/int16" target="_blank">Int16</a></li><li><a href="https://developer.apple.com/documentation/swift/int32" target="_blank">Int32</a></li><li><a href="https://developer.apple.com/documentation/swift/int64" target="_blank">Int64</a></li></ul><p>Unsigned integers:</p><ul><li><a href="https://developer.apple.com/documentation/swift/uint8" target="_blank">UInt8</a></li><li><a href="https://developer.apple.com/documentation/swift/uint16" target="_blank">UInt16</a></li><li><a href="https://developer.apple.com/documentation/swift/uint32" target="_blank">UInt32</a></li><li><a href="https://developer.apple.com/documentation/swift/uint64" target="_blank">UInt64</a></li></ul><p>You should know that the Int and UInt type size may vary on different platforms (32 vs 64 bits), but in order to be consistent, Apple recommends to always prefer the generic Int type over all the other variants. The Swift language always identifies all the integers using the Int type by default, so if you keep using this type you'll be able to perform integer operations without type conversions, your code will be easier to read and it's going to be easier to move between platforms too. üí™</p><p>Most of the time you shouldn't care about the length of the integer types, we can say that the generic Int and UInt types are quite often the best choices when you write Swift code. Except in those cases when your goal is to write extremely memory efficient or low level code...</p><h2>Representing numbers as integers</h2><p>Now that we know what kind of integers are available in Swift, it's time to talk a bit about what kind of numbers can we represent using these data types.</p><pre><code class="language-swift"><span class="comment">/// generic integers</span>
<span class="call">print</span>(<span class="type">Int</span>.<span class="property">min</span>)      <span class="comment">//  -9223372036854775808</span>
<span class="call">print</span>(<span class="type">Int</span>.<span class="property">max</span>)      <span class="comment">//   9223372036854775807</span>
<span class="call">print</span>(<span class="type">UInt</span>.<span class="property">min</span>)     <span class="comment">//                     0</span>
<span class="call">print</span>(<span class="type">UInt</span>.<span class="property">max</span>)     <span class="comment">//  18446744073709551615

/// unsigned integers</span>
<span class="call">print</span>(<span class="type">UInt8</span>.<span class="property">min</span>)    <span class="comment">//                     0</span>
<span class="call">print</span>(<span class="type">UInt8</span>.<span class="property">max</span>)    <span class="comment">//                   255</span>
<span class="call">print</span>(<span class="type">UInt16</span>.<span class="property">min</span>)   <span class="comment">//                     0</span>
<span class="call">print</span>(<span class="type">UInt16</span>.<span class="property">max</span>)   <span class="comment">//                 65535</span>
<span class="call">print</span>(<span class="type">UInt32</span>.<span class="property">min</span>)   <span class="comment">//                     0</span>
<span class="call">print</span>(<span class="type">UInt32</span>.<span class="property">max</span>)   <span class="comment">//            4294967295</span>
<span class="call">print</span>(<span class="type">UInt64</span>.<span class="property">min</span>)   <span class="comment">//                     0</span>
<span class="call">print</span>(<span class="type">UInt64</span>.<span class="property">max</span>)   <span class="comment">//  18446744073709551615

/// signed integers</span>
<span class="call">print</span>(<span class="type">Int8</span>.<span class="property">min</span>)     <span class="comment">//                  -128</span>
<span class="call">print</span>(<span class="type">Int8</span>.<span class="property">max</span>)     <span class="comment">//                   127</span>
<span class="call">print</span>(<span class="type">Int16</span>.<span class="property">min</span>)    <span class="comment">//                -32768</span>
<span class="call">print</span>(<span class="type">Int16</span>.<span class="property">max</span>)    <span class="comment">//                 32767</span>
<span class="call">print</span>(<span class="type">Int32</span>.<span class="property">min</span>)    <span class="comment">//           -2147483648</span>
<span class="call">print</span>(<span class="type">Int32</span>.<span class="property">max</span>)    <span class="comment">//            2147483647</span>
<span class="call">print</span>(<span class="type">Int64</span>.<span class="property">min</span>)    <span class="comment">//  -9223372036854775808</span>
<span class="call">print</span>(<span class="type">Int64</span>.<span class="property">max</span>)    <span class="comment">//   9223372036854775807</span></code></pre><p>So there is a minimum and maximum value for each integer type that we can store in a given variable. For example, we can't store the value 69420 inside a UInt8 type, because there are simply not enough <a href="https://en.wikipedia.org/wiki/Bit" target="_blank">bits</a> to represent this huge number. ü§ì</p><p>Let's examine our 8 bit long unsigned integer type. 8 bit means that we have literally 8 places to store <a href="https://theswiftdev.com/all-about-the-bool-type-in-swift/">boolean</a> values (ones and zeros) using the <a href="https://en.wikipedia.org/wiki/Binary_number" target="_blank">binary number</a> representation. 0101 0110 in binary is 86 using the "regular" decimal number format. This binary number is a base-2 numerical system (a positional notation) with a radix of 2. The number 86 can be interpreted as:</p><pre><code>0*28+1*27+0*26+1*25+0*24 + 1*23+1*22+0*21+0*20
0*128+1*64+0*32+1*16 + 0*8+1*4+1*2+0*1
64+16+4+2
86
</code></pre><p>We can convert back and forth between decimal and binary numbers, it's not that hard at all, but let's come back to this topic later on. In Swift we can check if a type is a signed type and we can also get the length of the integer type through the bitWidth property.</p><pre><code class="language-swift"><span class="call">print</span>(<span class="type">Int</span>.<span class="property">isSigned</span>)     <span class="comment">// true</span>
print(<span class="type">UInt</span>.<span class="property">isSigned</span>)    <span class="comment">// false</span>
print(<span class="type">Int</span>.<span class="property">bitWidth</span>)     <span class="comment">// 64</span>
<span class="call">print</span>(<span class="type">UInt8</span>.<span class="property">bitWidth</span>)   <span class="comment">// 8</span></code></pre><p>Based on this logic, now it's quite straightforward that an 8 bit long unsigned type can only store 255 as the maximum value (1111 1111), since that's 128+64+32+16+8+4+2+1.</p><p>What about signed types? Well, the trick is that 1 bit from the 8 is reserved for the positive / negative symbol. Usually the first bit represents the sign and the remaining 7 bits can store the actual numeric values. For example the Int8 type can store numbers from -128 til 127, since the maximum positive value is represented as 0111 1111, 64+32+16+8+4+2+1, where the leading zero indicates that we're talking about a positive number and the remaining 7 bits are all ones.</p><p>So how the hack can we represent -128? Isn't -127 (1111 1111) the minimum negative value? üòÖ</p><p>Nope, that's not how negative binary numbers work. In order to understand negative integer representation using binary numbers, first we have to introduce a new term called <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">two's complement</a>, which is a simple method of signed number representation.</p><h2>Basic signed number maths</h2><p>It is relatively easy to add two binary numbers, you just add the bits in order with a carry, just like you'd do addition using decimal numbers. Subtraction on the other hand is a bit harder, but fortunately it can be replaced with an addition operation if we store negative numbers in a special way and this is where two's complement comes in.</p><p>Let's imagine that we'd like to add two numbers:</p><ul><li><code>0010 1010</code> (+42)</li><li><code>0100 0101</code> +(+69)</li><li><code>0110 1111</code> =(+111)</li></ul><p>Now let's add a positive and a negative number stored using two's complement, first we need to express -6 using a signed 8 bit binary number format:</p><ul><li><code>0000 0110</code> (+6)</li><li><code>1111 1001</code> (<a href="https://en.wikipedia.org/wiki/Ones%27_complement" target="_blank">one's complement</a> = inverted bits)</li><li><code>1111 1010</code> (two's complement = add +1 (<code>0000 0001</code>) to one's complement)</li></ul><p>Now we can simply perform an addition operation on the positive and negative numbers.</p><ul><li><code>0010 1010</code> (+42)</li><li><code>1111 1010</code> +(-6)</li><li><code>(1) 0010 0100</code> =(+36)</li></ul><p>So, you might think, what's the deal with the extra 1 in the beginning of the 8 bit result? Well, that's called a carry bit, and in our case it won't affect our final result, since we've performed a subtraction instead of an addition. As you can see the remaining 8 bit represents the positive number 36 and 42-6 is exactly 36, we can simply ignore the extra flag for now. üòÖ</p><h2>Binary operators in Swift</h2><p>Enough from the theory, let's dive in with some real world examples using the UInt8 type. First of all, we should talk <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html" target="_blank">about bitwise operators</a> in Swift. In my previous article we've talked about <a href="https://theswiftdev.com/all-about-the-bool-type-in-swift/">Bool operators</a> (AND, OR, NOT) and the Boolean algebra, now we can say that those functions operate using a single bit. This time we're going to see how bitwise operators can perform various transformations using multiple bits. In our sample cases it's always going to be 8 bit. ü§ì</p><h3>Bitwise NOT operator</h3><p>This operator (<code>~</code>) inverts all bits in a number. We can use it to create one's complement values.</p><pre><code class="language-swift"><span class="comment">// one's complement</span>
<span class="keyword">let</span> x: <span class="type">UInt8</span> = 0b00000110    <span class="comment">// 6 using binary format</span>
<span class="keyword">let</span> res = ~x                 <span class="comment">// bitwise NOT</span>
<span class="call">print</span>(res)                   <span class="comment">// 249, but why?</span>
<span class="call">print</span>(<span class="type">String</span>(res, radix: <span class="number">2</span>)) <span class="comment">// 1111 1001</span></code></pre><p>Well, the problem is that we'll keep seeing decimal numbers all the time when using int types in Swift. We can print out the correct 1111 1001 result, using a String value with the base of 2, but for some reason the inverted number represents 249 according to our debug console. üôÉ</p><p>This is because the meaning of the UInt8 type has no understanding about the sign bit, and the 8th bit is always refers to the 28 value. Still, in some cases e.g. when you do low level programming, such as building a <a href="https://github.com/tib/SwiftNES" target="_blank">NES emulator written in Swift</a>, this is the right data type to choose.</p><p>The <a href="https://developer.apple.com/documentation/foundation/data" target="_blank">Data type</a> from the Foundation framework is considered to be a collection of UInt8 numbers. Actually you'll find quite a lot of use-cases for the UInt8 type if you take a deeper look at the existing frameworks &amp; libraries. Cryptography, data transfers, etc.</p><p>Anyway, you can make an extension to easily print out the binary representation for any unsigned 8 bit number with leading zeros if needed. 0Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£0Ô∏è‚É£ 0Ô∏è‚É£1Ô∏è‚É£1Ô∏è‚É£0Ô∏è‚É£</p><pre><code class="language-swift"><span class="comment">/// UInt8+Binary.swift</span>
<span class="keyword">import</span> Foundation

<span class="keyword">fileprivate extension</span> <span class="type">String</span> {
    
    <span class="keyword">func</span> leftPad(with character: <span class="type">Character</span>, length: <span class="type">UInt</span>) -&gt; <span class="type">String</span> {
        <span class="keyword">let</span> maxLength = <span class="type">Int</span>(length) - count
        <span class="keyword">guard</span> maxLength &gt; <span class="number">0</span> <span class="keyword">else</span> {
            <span class="keyword">return self</span>
        }
        <span class="keyword">return</span> <span class="type">String</span>(repeating: <span class="type">String</span>(character), count: maxLength) + <span class="keyword">self</span>
    }
}

<span class="keyword">extension</span> <span class="type">UInt8</span> {
    <span class="keyword">var</span> bin: <span class="type">String</span> {
        <span class="type">String</span>(<span class="keyword">self</span>, radix: <span class="number">2</span>).<span class="call">leftPad</span>(with: <span class="string">"0"</span>, length: <span class="number">8</span>)
    }
}

<span class="keyword">let</span> x: <span class="type">UInt8</span> = 0b00000110   <span class="comment">// 6 using binary format</span>
<span class="call">print</span>(<span class="type">String</span>(x, radix: <span class="number">2</span>))  <span class="comment">// 110</span>
<span class="call">print</span>(x.<span class="property">bin</span>)                <span class="comment">// 00000110</span>
<span class="call">print</span>((~x).<span class="property">bin</span>)             <span class="comment">// 11111001 - one's complement</span>
<span class="keyword">let</span> res = (~x) + <span class="number">1</span>          <span class="comment">// 11111010 - two's complement</span>
<span class="call">print</span>(res.<span class="property">bin</span>)</code></pre><p>We still have to provide our custom logic if we want to express signed numbers using UInt8, but that's only going to happen after we know more about the other bitwise operators.</p><h3>Bitwise AND, OR, XOR operators</h3><p>These operators works just like you'd expect it from the truth tables. The AND operator returns a one if both the bits were true, the OR operator returns a 1 if either of the bits were true and the XOR operator only returns a true value if only one of the bits were true.</p><ul><li>AND <code>&amp;</code> - 1 if both bits were 1</li><li>OR <code>|</code> - 1 if either of the bits were 1</li><li>XOR <code>^</code> - 1 if only one of the bits were 1</li><li> Let me show you a quick example for each operator in Swift.</li></ul><pre><code class="language-swift"><span class="keyword">let</span> x: <span class="type">UInt8</span> = <span class="number">42</span>   <span class="comment">// 00101010</span>
<span class="keyword">let</span> y: <span class="type">UInt8</span> = <span class="number">28</span>   <span class="comment">// 00011100
// AND</span>
<span class="call">print</span>((x &amp; y).<span class="property">bin</span>)  <span class="comment">// 00001000
// OR</span>
<span class="call">print</span>((x | y).<span class="property">bin</span>)  <span class="comment">// 00111110
// XOR</span>
<span class="call">print</span>((x ^ y).<span class="property">bin</span>)  <span class="comment">// 00110110</span></code></pre><p>Mathematically speaking, there is not much reason to perform these operations, it won't give you a sum of the numbers or other basic calculation results, but they have a different purpose.</p><p>You can use the bitwise AND operator to extract bits from a given number. For example if you want to store 8 (or less) individual true or false values using a single UInt8 type you can use a bitmask to extract &amp; set given parts of the number. üò∑</p><pre><code class="language-swift"><span class="keyword">var</span> statusFlags: <span class="type">UInt8</span> = 0b00000100

<span class="comment">// check if the 3rd flag is one (value equals to 4)</span>
<span class="call">print</span>(statusFlags &amp; 0b00000100 == <span class="number">4</span>)   <span class="comment">// true

// check if the 5th flag is one (value equals to 16)</span>
<span class="call">print</span>(statusFlags &amp; 0b00010000 == <span class="number">16</span>)  <span class="comment">// false

// set the 5th flag to 1</span>
statusFlags = statusFlags &amp; 0b11101111 | <span class="number">16</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>)  <span class="comment">// 00010100

// set the 3rd flag to zero</span>
statusFlags = statusFlags &amp; 0b11111011 | <span class="number">0</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>) <span class="comment">// 00000100

// set the 5th flag back to zero</span>
statusFlags = statusFlags &amp; 0b11101111 | <span class="number">0</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>) <span class="comment">// 00000000

// set the 3rd flag back to one</span>
statusFlags = statusFlags &amp; 0b11101011 | <span class="number">4</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>) <span class="comment">// 00000100</span></code></pre><p>This is nice, especially if you don't want to mess around with 8 different Bool variables, but one there is one thing that is very inconvenient about this solution. We always have to use the right power of two, of course we could use <a href="https://developer.apple.com/documentation/foundation/1779833-pow" target="_blank">pow</a>, but there is a more elegant solution for this issue.</p><h3>Bitwise left &amp; right shift operators</h3><p>By using a bitwise shift operation you can move a bit in a given number to left or right. Left shift is essentially a multiplication operation and right shift is identical with a division by a factor of two.</p><blockquote><p>"Shifting an integer‚Äôs bits to the left by one position doubles its value, whereas shifting it to the right by one position halves its value." - <a href="https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID34" target="_blank">swift.org</a></p></blockquote><p>It's quite simple, but let me show you a few practical examples so you'll understand it in a bit. üòÖ</p><pre><code class="language-swift"><span class="keyword">let</span> meaningOfLife: <span class="type">UInt8</span> = <span class="number">42</span>


<span class="comment">// left shift 1 bit (42 * 2)</span>
<span class="call">print</span>(meaningOfLife &lt;&lt; <span class="number">1</span>) <span class="comment">// 84

// left shift 2 bits (42 * 2 * 2)</span>
<span class="call">print</span>(meaningOfLife &lt;&lt; <span class="number">2</span>) <span class="comment">// 168

// left shift 3 bits (42 * 2 * 2 * 2)</span>
<span class="call">print</span>(meaningOfLife &lt;&lt; <span class="number">3</span>) <span class="comment">// 80, it's an overflow !!!


// right shift 1 bit (42 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">1</span>) <span class="comment">// 21

// right shift 2 bits (42 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">2</span>) <span class="comment">// 10

// right shift 3 bits (42 / 2 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">3</span>) <span class="comment">// 5

// right shift 4 bits (42 / 2 / 2 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">4</span>) <span class="comment">// 2

// right shift 5 bits (42 / 2 / 2 / 2 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">5</span>) <span class="comment">// 1

// right shift 6 bits (42 / 2 / 2 / 2 / 2 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">6</span>) <span class="comment">// 0

// right shift 7 bits (42 / 2 / 2 / 2 / 2 / 2 / 2 / 2)</span>
<span class="call">print</span>(meaningOfLife &gt;&gt; <span class="number">7</span>) <span class="comment">// 0</span></code></pre><p>As you can see we have to be careful with left shift operations, since the result can overflow the 8 bit range. If this happens, the extra bit will just go away and the remaining bits are going to be used as a final result. Right shifting is always going to end up as a zero value. ‚ö†Ô∏è</p><p>Now back to our status flag example, we can use bit shifts, to make it more simple.</p><pre><code class="language-swift"><span class="keyword">var</span> statusFlags: <span class="type">UInt8</span> = 0b00000100

<span class="comment">// check if the 3rd flag is one</span>
<span class="call">print</span>(statusFlags &amp; <span class="number">1</span> &lt;&lt; <span class="number">2</span> == <span class="number">1</span> &lt;&lt; <span class="number">2</span>)

<span class="comment">// set the 3rd flag to zero</span>
statusFlags = statusFlags &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | <span class="number">0</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>)

<span class="comment">// set back the 3rd flag to one</span>
statusFlags = statusFlags &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) | <span class="number">1</span> &lt;&lt; <span class="number">2</span>
<span class="call">print</span>(statusFlags.<span class="property">bin</span>)</code></pre><p>As you can see we've used quite a lot of bitwise operations here. For the first check we use left shift to create our mask, bitwise and to extract the value using the mask and finally left shift again to compare it with the underlying value. Inside the second set operation we use left shift to create a mask then we use the not operator to invert the bits, since we're going to set the value using a bitwise or function. I suppose you can figure out the last line based on this info, but if not just practice these operators, they are very nice to use once you know all the little the details. ‚ò∫Ô∏è</p><p>I think I'm going to cut it here, and I'll make just another post about overflows, carry bits and various transformations, maybe we'll involve hex numbers as well, anyway don't want to promise anything specific. Bitwise operations are usueful and fun, just practice &amp; don't be afraid of a bit of math. üëæ</p>
        </section>
    </div>

</article>

<section id="share" class="content-wrapper">
    <p>
    <a
        href="https://x.com/intent/tweet?via=tiborbodecs&amp;hashtags=SwiftLang&amp;url=https://theswiftdev.com/practical-guide-to-binary-operations-using-the-uint8-type-in-swift/"
        target="_blank"
    >
        Share this article
    </a>
    <br> Thank you. üôè</p>
</section>

<section  class="wrapper">
    <div id="book">
        <div class="column left">
            <img src="https://theswiftdev.com/images/practical-server-side-swift-cover.png">
        </div>
        <div class="column right">
            <h3>Get the Practical Server Side Swift book</h3>
            <p>Swift on the server is an amazing new opportunity to build fast, safe and scalable backend apps. Write your very first web-based application by using your favorite programming language. Learn how to build a modular blog engine using the latest version of the Vapor 4 framework. This book will help you to design and create modern APIs that'll allow you to share code between the server side and iOS. Start becoming a full-stack Swift developer.</p>
            <a class="button" href="https://gumroad.com/l/practical-server-side-swift" target="_blank">Available on Gumroad</a>
        </div>
    </div>
</section>

<section id="author" class="content-wrapper">
    <img 
        id="author-image"
        src="https://theswiftdev.com/images/profiles/tiborbodecs.jpg"
        alt="Picture of Tibor B√∂decs" 
        title="Tibor B√∂decs"
    >
    <h3>Tibor B√∂decs</h3>
    <p class="title">CEO @ <a href="https://binarybirds.com/">Binary Birds</a></p>
    <p class="bio">Server side Swift enthusiast, book author, content creator.</p>

    <div class="links">
        <a href="mailto:mail.tib@gmail.com?subject=theswiftdev.com" target="_blank">Email</a> ¬∑ 
        <a href="https://x.com/tiborbodecs" target="_blank">X</a> ¬∑ 
        <a href="https://github.com/tib" target="_blank">GitHub</a> 
    </div>
</section>

        
    </main>

    <footer>
        <section class="content-wrapper">
            <img 
                src="https://theswiftdev.com/images/icons/icon-320.png"
                alt="Logo of The.Swift.Dev." 
                title="The.Swift.Dev."
            >

            <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
            
            <p> 
                <a href="https://theswiftdev.com/">Home</a> ¬∑
                <a href="https://theswiftdev.com/rss.xml" target="_blank">RSS</a> ¬∑
                <a href="https://theswiftdev.com/sitemap.xml" target="_blank">Sitemap</a>
            </p>
            
            <p class="small">Created by Tibor B√∂decs &copy; 2015 - 2023.</p>
        </section>
    </footer>
</body>
</html>
